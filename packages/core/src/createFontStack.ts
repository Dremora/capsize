import type { AtRule } from 'csstype';
import { round } from './round';
import type { FontMetrics } from './types';

const toPercentString = (value: number) => `${round(value * 100)}%`;

export const toCssProperty = (property: string) =>
  property.replace(/([A-Z])/g, (property) => `-${property.toLowerCase()}`);

type FontStackMetrics = Pick<
  FontMetrics,
  | 'familyName'
  | 'ascent'
  | 'descent'
  | 'lineGap'
  | 'unitsPerEm'
  | 'xWidthAvg'
  | 'xWidthAvgByLang'
>;

type Language = keyof FontMetrics['xWidthAvgByLang'];

interface OverrideValuesParams {
  metrics: FontStackMetrics;
  fallbackMetrics: FontStackMetrics;
  language: Language;
}
const calculateOverrideValues = ({
  metrics,
  fallbackMetrics,
  language,
}: OverrideValuesParams): AtRule.FontFace => {
  const preferredAvgWidth =
    'xWidthAvgByLang' in metrics
      ? metrics.xWidthAvgByLang[language]
      : metrics.xWidthAvg;
  const fallbackAvgWidth =
    'xWidthAvgByLang' in fallbackMetrics
      ? fallbackMetrics.xWidthAvgByLang[language]
      : fallbackMetrics.xWidthAvg;

  // Calculate size adjust
  const preferredFontXAvgRatio = preferredAvgWidth / metrics.unitsPerEm;
  const fallbackFontXAvgRatio = fallbackAvgWidth / fallbackMetrics.unitsPerEm;

  const sizeAdjust =
    preferredFontXAvgRatio && fallbackFontXAvgRatio
      ? preferredFontXAvgRatio / fallbackFontXAvgRatio
      : 1;

  const adjustedEmSquare = metrics.unitsPerEm * sizeAdjust;

  // Calculate metric overrides for preferred font
  const ascentOverride = metrics.ascent / adjustedEmSquare;
  const descentOverride = Math.abs(metrics.descent) / adjustedEmSquare;
  const lineGapOverride = metrics.lineGap / adjustedEmSquare;

  // Calculate metric overrides for fallback font
  const fallbackAscentOverride = fallbackMetrics.ascent / adjustedEmSquare;
  const fallbackDescentOverride =
    Math.abs(fallbackMetrics.descent) / adjustedEmSquare;
  const fallbackLineGapOverride = fallbackMetrics.lineGap / adjustedEmSquare;

  // Conditionally populate font face properties and format to percent
  const fontFace: AtRule.FontFace = {};
  if (ascentOverride && ascentOverride !== fallbackAscentOverride) {
    fontFace['ascentOverride'] = toPercentString(ascentOverride);
  }
  if (descentOverride && descentOverride !== fallbackDescentOverride) {
    fontFace['descentOverride'] = toPercentString(descentOverride);
  }
  if (lineGapOverride && lineGapOverride !== fallbackLineGapOverride) {
    fontFace['lineGapOverride'] = toPercentString(lineGapOverride);
  }
  if (sizeAdjust && sizeAdjust !== 1) {
    fontFace['sizeAdjust'] = toPercentString(sizeAdjust);
  }

  return fontFace;
};

export const quoteIfNeeded = (name: string) => {
  const quotedMatch = name.match(/^['"](?<name>.*)['"]$/);
  if (quotedMatch && quotedMatch.groups?.name) {
    // Escape double quotes in middle of name
    return `"${quotedMatch.groups.name.split(`"`).join(`\"`)}"`;
  }

  if (/^"/.test(name)) {
    // Complete double quotes if incomplete and escape double quotes in middle
    const [, ...restName] = name;
    return `"${restName.map((x) => (x === `"` ? `\"` : x)).join('')}"`;
  }

  if (!/^[a-zA-Z\d\-_]+$/.test(name)) {
    // Wrap in quotes if contains any characters that are not letters,
    // numbers, hyphens or underscores
    return `"${name.split(`"`).join(`\"`)}"`;
  }

  return name;
};

type FontFace = {
  '@font-face': Omit<AtRule.FontFace, 'src' | 'fontFamily'> &
    Required<Pick<AtRule.FontFace, 'src' | 'fontFamily'>>;
};
const toCssString = (fontFaces: FontFace[]) => {
  return fontFaces
    .map(({ '@font-face': { fontFamily, src, ...restFontFaceProperties } }) => {
      const fontFace = [
        '@font-face {',
        `  font-family: ${quoteIfNeeded(fontFamily)};`,
        `  src: ${src};`,
      ];

      Object.keys(restFontFaceProperties).forEach((property) => {
        fontFace.push(
          `  ${toCssProperty(property)}: ${
            restFontFaceProperties[
              property as keyof typeof restFontFaceProperties
            ]
          };`,
        );
      });

      fontFace.push('}');

      return fontFace.join('\n');
    })
    .join('\n');
};

type AdditionalFontFaceProperties = Omit<
  AtRule.FontFace,
  | 'src'
  | 'fontFamily'
  | 'ascentOverride'
  | 'descentOverride'
  | 'lineGapOverride'
>;
type CreateFontStackOptions = {
  /**
   * Additional properties to add to the generated `@font-face` declarations.
   *
   * Accepts all valid `@font-face` properties except the following which are
   * generated by Capsize: `src`, `fontFamily`, `ascentOverride`,
   * `descentOverride`, `lineGapOverride`, although allows `size-adjust` to
   * support explicit overrides.
   */
  fontFaceProperties?: AdditionalFontFaceProperties;
  language?: Language;
};
type FontFaceFormatString = {
  /**
   * Choose between returning CSS as a string for stylesheets or `style` tags,
   * or as a style object for CSS-in-JS integration.
   *
   * Default: `styleString`
   */
  fontFaceFormat?: 'styleString';
};
type FontFaceFormatObject = {
  fontFaceFormat?: 'styleObject';
};

export function createFontStack(
  fontStackMetrics: FontStackMetrics[],
  options?: CreateFontStackOptions & FontFaceFormatString,
): { fontFamily: string; fontFaces: string };
export function createFontStack(
  fontStackMetrics: FontStackMetrics[],
  options?: CreateFontStackOptions & FontFaceFormatObject,
): { fontFamily: string; fontFaces: FontFace[] };
export function createFontStack(
  [metrics, ...fallbackMetrics]: FontStackMetrics[],
  optionsArg: CreateFontStackOptions = {},
) {
  if (optionsArg.language && !metrics.xWidthAvgByLang) {
    throw new Error(
      `Specifying the 'language' option is only available when the provided metrics contain \`xWidthAvgByLang\`. You may need to update the '@capsizecss/metrics' or '@capsizecss/unpack' package.`,
    );
  }

  const {
    fontFaceFormat,
    fontFaceProperties,
    language = 'en',
  } = {
    fontFaceFormat: 'styleString',
    ...optionsArg,
  };
  const { familyName } = metrics;

  const fontFamilies: string[] = [quoteIfNeeded(familyName)];
  const fontFaces: FontFace[] = [];

  fallbackMetrics.forEach((fallback) => {
    if (optionsArg.language && !fallback.xWidthAvgByLang) {
      throw new Error(
        `Specifying the 'language' option is only available when the provided metrics contain \`xWidthAvgByLang\`. You may need to update the '@capsizecss/metrics' or '@capsizecss/unpack' package.`,
      );
    }

    const fontFamily = `${familyName} Fallback${
      fallbackMetrics.length > 1 ? `: ${fallback.familyName}` : ''
    }`;

    fontFamilies.push(quoteIfNeeded(fontFamily));
    fontFaces.push({
      '@font-face': {
        ...fontFaceProperties,
        fontFamily,
        src: `local('${fallback.familyName}')`,
        ...calculateOverrideValues({
          metrics,
          fallbackMetrics: fallback,
          language,
        }),
        ...(fontFaceProperties?.sizeAdjust
          ? { sizeAdjust: fontFaceProperties.sizeAdjust }
          : {}),
      },
    });
  });

  return {
    fontFamily: fontFamilies.join(', '),
    fontFaces: {
      styleString: toCssString(fontFaces),
      styleObject: fontFaces,
    }[fontFaceFormat],
  };
}
